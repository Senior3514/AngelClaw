"""AngelClaw V4.0 â€” Omniscience: Vulnerability Scanner Integration.

Manages vulnerability findings linked to assets, tracks remediation status,
and computes vulnerability-based risk scores.
"""

from __future__ import annotations

import logging
import uuid
from collections import defaultdict
from datetime import datetime, timezone
from typing import Any

from pydantic import BaseModel, Field

logger = logging.getLogger("angelclaw.vulnerability")

_SEVERITY_ORDER = {"critical": 5, "high": 4, "medium": 3, "low": 2, "info": 1}


class VulnerabilityFinding(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str = "dev-tenant"
    asset_id: str
    cve_id: str | None = None
    title: str
    description: str = ""
    severity: str = "medium"
    cvss_score: str | None = None
    status: str = "open"  # open, mitigated, accepted, false_positive
    remediation: str = ""
    scanner_source: str = "angelclaw"
    found_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    resolved_at: datetime | None = None


class VulnerabilityService:
    """Vulnerability management with asset-linked findings."""

    def __init__(self) -> None:
        self._findings: dict[str, VulnerabilityFinding] = {}
        self._tenant_findings: dict[str, list[str]] = defaultdict(list)

    def report_finding(
        self,
        tenant_id: str,
        asset_id: str,
        title: str,
        severity: str = "medium",
        cve_id: str | None = None,
        description: str = "",
        cvss_score: str | None = None,
        remediation: str = "",
        scanner_source: str = "angelclaw",
    ) -> dict:
        finding = VulnerabilityFinding(
            tenant_id=tenant_id,
            asset_id=asset_id,
            title=title,
            severity=severity,
            cve_id=cve_id,
            description=description,
            cvss_score=cvss_score,
            remediation=remediation,
            scanner_source=scanner_source,
        )
        self._findings[finding.id] = finding
        self._tenant_findings[tenant_id].append(finding.id)
        logger.info("[VULN] Reported: %s (%s) on asset %s", title, severity, asset_id[:8])
        return finding.model_dump(mode="json")

    def get_finding(self, finding_id: str) -> dict | None:
        f = self._findings.get(finding_id)
        return f.model_dump(mode="json") if f else None

    def list_findings(
        self,
        tenant_id: str,
        asset_id: str | None = None,
        severity: str | None = None,
        status: str | None = None,
        limit: int = 200,
    ) -> list[dict]:
        results = []
        for fid in self._tenant_findings.get(tenant_id, []):
            f = self._findings.get(fid)
            if not f:
                continue
            if asset_id and f.asset_id != asset_id:
                continue
            if severity and f.severity != severity:
                continue
            if status and f.status != status:
                continue
            results.append(f.model_dump(mode="json"))
            if len(results) >= limit:
                break
        return results

    def update_status(self, finding_id: str, status: str, resolved_by: str = "operator") -> dict | None:
        f = self._findings.get(finding_id)
        if not f:
            return None
        f.status = status
        if status in ("mitigated", "accepted", "false_positive"):
            f.resolved_at = datetime.now(timezone.utc)
        return f.model_dump(mode="json")

    def get_asset_risk(self, tenant_id: str, asset_id: str) -> dict:
        """Compute vulnerability-based risk score for an asset."""
        findings = [
            self._findings[fid] for fid in self._tenant_findings.get(tenant_id, [])
            if fid in self._findings and self._findings[fid].asset_id == asset_id
            and self._findings[fid].status == "open"
        ]
        if not findings:
            return {"asset_id": asset_id, "risk_score": 0, "open_vulns": 0}
        max_sev = max(_SEVERITY_ORDER.get(f.severity, 1) for f in findings)
        risk = min(100, max_sev * 15 + len(findings) * 3)
        return {
            "asset_id": asset_id,
            "risk_score": risk,
            "open_vulns": len(findings),
            "by_severity": {
                sev: sum(1 for f in findings if f.severity == sev)
                for sev in _SEVERITY_ORDER
            },
        }

    def get_stats(self, tenant_id: str) -> dict:
        findings = [
            self._findings[fid] for fid in self._tenant_findings.get(tenant_id, [])
            if fid in self._findings
        ]
        by_severity: dict[str, int] = defaultdict(int)
        by_status: dict[str, int] = defaultdict(int)
        for f in findings:
            by_severity[f.severity] += 1
            by_status[f.status] += 1
        return {
            "total": len(findings),
            "by_severity": dict(by_severity),
            "by_status": dict(by_status),
            "open": by_status.get("open", 0),
        }


# Module-level singleton
vulnerability_service = VulnerabilityService()
